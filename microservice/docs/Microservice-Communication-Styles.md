# Microservice Communication Styles

## 커뮤니케이션 종류
- 동기
    - Request-Response : REST(HTTP), RPC
- 비동기
    - Common Data
    - Request-Response : Message Broker
    - Event Driven Broker

## Pattern : Synchronous Blocking

## Pattern : Asynchronous Non-blocking

## Common Data
한 마이크로서비스가 데이터를 약속된 위치에 저장하고 다른 마이크로서비스들이 데이터를 읽어가는 상황. 

기술에 제한이 있을 수 있는 프로세스 간의 상호작용을 가능하게 해준다. gRPC 인터페이스 또는 Kafka를 통한 통신이 편할 수 있지만 해당 기술을 지원하지 않는 언어로 구현되어 있는 구형 시스템인 경우에 사용할 수 있다. 파일시스템은 모든 어떤 구형 시스템이라도 사용할 수 있다.

또는 크기가 큰 데이터를 공유할 때 사용한다. GB 단위의 데이터를 파일 시스템으로 보내야 하는 경우 이 패턴이 적합하다.

<img src="https://user-images.githubusercontent.com/44857109/104012618-795d6a00-51f3-11eb-91c9-0bd3d48b4f24.png" width="60%" height="60%">

### 구현
이 패턴은 데이터를 저장할 저장소가 필요하다. 데이터 저장소는 파일 시스템, 분산 메모리 저장소(Redis) 등을 사용한다.

일반적인 예는 데이터 레이크와 데이터 웨어하우스 이다. 일반적으로 데이터의 흐름은 한 방향으로 흘러야 한다. 만약 여러 개의 마이크로서비스가 함께 읽기 및 쓰기를 한다면 운영에 여러가지 문제가 생긴다.

- 데이터 레이크
    - 구조화되지 않은(목적이 없는 비정형) 데이터를 저장함
    - 데이터는 분석을 위해 필요할 때 변환됨 : schema on read
    - 사용자가 데이터 레이크에서 데이터를 다른 시스템으로 이동시킬 필요 없이 원하는 방식으로 그때 그때 데이터를 검색해서 가져감
- 데이터 웨어하우스
    - 데이터 웨어하우스는 구조화된 데이터 모델을 제공
    - 데이터가 데이터 웨어하우스에 저장되기 전에 처리되어야 함
    - 데이터 웨어하우스에 어떤 데이터를 포함시킬지 결정 : schema on write
    - 데이터를 저장하기 전에 정제하는 전처리는 시간이 오래 걸릴 수 있기 때문에 데이터를 바로 사용할 수 없다. 

### 장점
구현이 간단하다. 파일을 읽고 쓸수 있다면, 데이터페이스에 읽고 쓸 수 있다면 이 패턴으로 구현할 수 있다. 한번에 많은 데이터를 전송해야 하는 경우 잘 작동한다.

### 단점
다운 스트림 서비스는 폴링 방식을 통해 주기적으로 새로운 데이터가 생겼는지 인식하는 프로세스가 필요하다. 지연시간이 짧아야 하는 경우에는 사용할 수 없다.


## Request-Response
이 패턴에서 마이크로서비스는 다운 스트림 서비스에 요청을 보내고 해당 요청 결과에 대한 응답을 받아야 한다. 요청에 대한 응답은 동기/비동기 방식으로 구현될 수 있다. 

일반적인 사용은 다른 마이크로서비스에 있는 데이터를 검색하는 것이다. `Order Processor`는 `Warehouse`로 재고가 있는지 확인하는 요청을 보내고 응답의 내용에 따라 `Payment`로 결제 요청을 보내거나 해당 서비스가 받은 요청에 대해 결제 실패 응답을 보낼 수 있다.

<img src="https://user-images.githubusercontent.com/44857109/104017192-02c46a80-51fb-11eb-89ca-d1135262e7bb.png" width="60%" height="60%">

### 구현
비동기 형식으로 구현에서 각 마이크로서비스는 메시지 브로커를 사용하여 요청, 응답을 주고 받는다. 구현방식이 좀 복잡해진다.

<img src="https://user-images.githubusercontent.com/44857109/104017087-d3156280-51fa-11eb-9e03-904d11cc45c0.png" width="60%" height="60%">

요청을 받는 서비스는 해당 요청에 대한 응답을 어디로 보내야 할지 암시적으로 알아야 하거나 누군가가 알려줘야 한다. 반대로 응답을 받는 서비스는 해당 응답을 이전에 했던 요청과 매칭시켜야 한다. 만약 요청 서비스의 인스턴스가 여러개인 경우 요청에 대한 응답이 다른 인스턴스로 갈 수 있기 때문에 요청에 대한 상태정보를 DB 같은 곳에 저장해야 한다. 이후에 응답이 오면 요청에 대한 정보를 다시 로드해서 적절한 로직을 수행한다.

## Event Driven
마이크로서비스는 다른 서비스에게 어떤 데이터를 얻기 위해 요청하는 대신 일방적으로 이벤트를 전달한다. 이벤트를 전달하는 서비스는 이벤트를 사용하려는 다른 서비스의 의도를 알지 못하고 존재하는 사실도 인식하지 않는다.

<img src="https://user-images.githubusercontent.com/44857109/104019041-2fc64c80-51fe-11eb-8c1a-2636fe0dbf09.png" width="60%" height="60%">

`Warehouse`는 이벤트를 브로드케스트할 때 그에 따라 다운 스트림 서비스들이 각자 원하는 방식대로 이벤트를 처리할 것이라고만 예상한다. 즉 업스트림 서비스는 다운 스트림 서비스가 요구하는 정보를 알 필요가 없다. 반대로 다운 스트림 서비스는 업스트림 서비스가 전달하는 이벤트에 대한 정보를 알고 있어야 한다. 이러한 책임의 분배는 느슨한 결합으로 이어진다.

- 이벤트
    - 정확히 무슨 일이 일어났는지에 대한 정보 또는 어떠한 사실
- 메시지
    - 메시지 브로커와 같은 비동기 통신 메커니즘을 통해 보내는 것
    - 즉 메시지는 매체, 이벤트는 매체의 페이로드임

### 이벤트엔 어떤 정보를 담아야 하는가?
`Customer`는 새로운 소비자가 등록되면 해당 이벤트를 브로드케스트한다. 다운 스트림 서비스인 `Loyalty`, `Notifications`는 이벤트를 수신받고 적절한 로직을 수행한다. `Loyalty`는 사용자 식별자를 기반으로 포인트 적립을 위한 새로운 계좌를 생성한다. `Notifications`는 새로운 사용자에게 웰컴드링크같이 이메일을 전송한다.

<img src="https://user-images.githubusercontent.com/44857109/104026640-92711580-5209-11eb-8a3b-bdd1802c0183.png" width="60%" height="60%">

이벤트를 생성하는 마이크로서비스는 이벤트를 소비하는 서비스를 알 수 없고 이벤트에서 어떤 정보를 필요로 하는지 또한 알 수 없다. 그렇다면 이벤트에는 어떤 정보를 담아야 할까?

#### 식별자만 전달 (Customer ID)

<img src="https://user-images.githubusercontent.com/44857109/104026591-808f7280-5209-11eb-8431-56b415311e7b.png" width="60%" height="60%">

`Loyalty`는 사용자의 포인트 계좌를 만들기 위한 모든 정보를 전달받았기 때문에 추가적인 데이터 요청이 필요없다. 하지만 `Notifications`는 사용자의 이메일 주소, 이름과 같은 추가정보를 필요로 하기 때문에 `Customer`로 추가 데이터를 요청해야 한다.

이 방식은 `Customer <-> Notifications` 커플링을 추가하게 된다. 이제 `Notifications`는 `Customer`의 API 구현 정보를 알아야 하기 때문에 결합이 든든해진다. 최대한 느슨하게 결합을 유지해야 하기 때문에 적절한 방법은 아니다. 또한 이러한 방식은 이벤트를 수신하는 서비스가 많아지면 이벤트를 하나 전달할 때마다 수많은 콜백요청을 받을 수 있다. 

#### 최대한 자세하게 전달

<img src="https://user-images.githubusercontent.com/44857109/104026538-6bb2df00-5209-11eb-9853-e228b4d05d28.png" width="60%" height="60%">

이 방법은 API로 공유할 수 있는 모든 정보(data hiding을 통해 외부에게 숨겨야할 데이터를 제외한 모든 것)를 이벤트에 담는 것이다. 이 경우에 `Notifications`는 사용자에게 이메일을 전송하기 위해 필요한 모든 정보를 이벤트를 통해 전달받았기 때문에 추가적인 요청이 필요하지 않다. 덛붙여서 `Customer`의 존재 사실도 알 필요가 없다(이벤트의 형식에 대해서만 관심이 있음). 

이벤트에 최대한 많은 데이터를 넣는 것은 느슨한 결합 이외에도 모니터링 시스템을 만들 때 유용하게 쓰일 수 있다.

장점만 있는 것은 아니다. 먼저 이벤트 크기에 대한 제한이 있을 수 있다. 하지만 이는 걱정하지 않아도 된다. RabbitMQ가 처리하는 메시지의 최대 크기는 512MB이고 Kafka의 메시지 최대크기는 1MB이다. Kafka의 메시지 크기는 상대적으로 작은 것 같지만 이벤트 입장에서는 1MB도 넉넉하다.

진짜 문제가 될 수 있는 것은 특정 다운 스트림 서비스가 볼 수 있는 이벤트 데이터 범위를 제한하려 할 때이다.

또다른 문제는 한번 데이터를 이벤트에 담으면 외부 서비스와의 계약의 일부가 되는 것이다. 이벤트의 내용을 수정할 때 특정 필드를 제거하면 해당 필드를 사용하는 외부 서비스에서 오류가 날 수 있다. 즉 들어올땐 마음대로지만 나갈 땐 아니다. 글쓴이의 추천은 만약 Request-Response API로 구현했을 때 공유했어야 할만한 데이터들을 이벤트에 담는 것이다.