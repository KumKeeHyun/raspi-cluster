# Microservice Communication Styles

## 커뮤니케이션 종류
- 동기
    - Request-Response : REST(HTTP), RPC
- 비동기
    - Common Data
    - Request-Response : Message Broker
    - Event Driven Broker

## Pattern : Synchronous Blocking

## Pattern : Asynchronous Non-blocking

## Common Data
한 마이크로서비스가 데이터를 약속된 위치에 저장하고 다른 마이크로서비스들이 데이터를 읽어가는 상황. 

기술에 제한이 있을 수 있는 프로세스 간의 상호작용을 가능하게 해준다. gRPC 인터페이스 또는 Kafka를 통한 통신이 편할 수 있지만 해당 기술을 지원하지 않는 언어로 구현되어 있는 구형 시스템인 경우에 사용할 수 있다. 파일시스템은 모든 어떤 구형 시스템이라도 사용할 수 있다.

또는 크기가 큰 데이터를 공유할 때 사용한다. GB 단위의 데이터를 파일 시스템으로 보내야 하는 경우 이 패턴이 적합하다.

<img src="https://user-images.githubusercontent.com/44857109/104012618-795d6a00-51f3-11eb-91c9-0bd3d48b4f24.png" width="60%" height="60%">

### 구현
이 패턴은 데이터를 저장할 저장소가 필요하다. 데이터 저장소는 파일 시스템, 분산 메모리 저장소(Redis) 등을 사용한다.

일반적인 예는 데이터 레이크와 데이터 웨어하우스 이다. 일반적으로 데이터의 흐름은 한 방향으로 흘러야 한다. 만약 여러 개의 마이크로서비스가 함께 읽기 및 쓰기를 한다면 운영에 여러가지 문제가 생긴다.

- 데이터 레이크
    - 구조화되지 않은(목적이 없는 비정형) 데이터를 저장함
    - 데이터는 분석을 위해 필요할 때 변환됨 : schema on read
    - 사용자가 데이터 레이크에서 데이터를 다른 시스템으로 이동시킬 필요 없이 원하는 방식으로 그때 그때 데이터를 검색해서 가져감
- 데이터 웨어하우스
    - 데이터 웨어하우스는 구조화된 데이터 모델을 제공
    - 데이터가 데이터 웨어하우스에 저장되기 전에 처리되어야 함
    - 데이터 웨어하우스에 어떤 데이터를 포함시킬지 결정 : schema on write
    - 데이터를 저장하기 전에 정제하는 전처리는 시간이 오래 걸릴 수 있기 때문에 데이터를 바로 사용할 수 없다. 

### 장점
구현이 간단하다. 파일을 읽고 쓸수 있다면, 데이터페이스에 읽고 쓸 수 있다면 이 패턴으로 구현할 수 있다. 한번에 많은 데이터를 전송해야 하는 경우 잘 작동한다.

### 단점
다운 스트림 서비스는 폴링 방식을 통해 주기적으로 새로운 데이터가 생겼는지 인식하는 프로세스가 필요하다. 지연시간이 짧아야 하는 경우에는 사용할 수 없다.


## Request-Response
이 패턴에서 마이크로서비스는 다운 스트림 서비스에 요청을 보내고 해당 요청 결과에 대한 응답을 받아야 한다. 요청에 대한 응답은 동기/비동기 방식으로 구현될 수 있다. 

일반적인 사용은 다른 마이크로서비스에 있는 데이터를 검색하는 것이다. `Order Processor`는 `Warehouse`로 재고가 있는지 확인하는 요청을 보내고 응답의 내용에 따라 `Payment`로 결제 요청을 보내거나 해당 서비스가 받은 요청에 대해 결제 실패 응답을 보낼 수 있다.

<img src="https://user-images.githubusercontent.com/44857109/104017192-02c46a80-51fb-11eb-89ca-d1135262e7bb.png" width="60%" height="60%">

### 구현
비동기 형식으로 구현에서 각 마이크로서비스는 메시지 브로커를 사용하여 요청, 응답을 주고 받는다. 구현방식이 좀 복잡해진다.

<img src="https://user-images.githubusercontent.com/44857109/104017087-d3156280-51fa-11eb-9e03-904d11cc45c0.png" width="60%" height="60%">

요청을 받는 서비스는 해당 요청에 대한 응답을 어디로 보내야 할지 암시적으로 알아야 하거나 누군가가 알려줘야 한다. 반대로 응답을 받는 서비스는 해당 응답을 이전에 했던 요청과 매칭시켜야 한다. 만약 요청 서비스의 인스턴스가 여러개인 경우 요청에 대한 응답이 다른 인스턴스로 갈 수 있기 때문에 요청에 대한 상태정보를 DB 같은 곳에 저장해야 한다. 이후에 응답이 오면 요청에 대한 정보를 다시 로드해서 적절한 로직을 수행한다.

## Event Driven
마이크로서비스는 다른 서비스에게 어떤 데이터를 얻기 위해 요청하는 대신 일방적으로 이벤트를 전달한다. 이벤트를 전달하는 서비스는 이벤트를 사용하려는 다른 서비스의 의도를 알지 못하고 존재하는 사실도 인식하지 않는다.

<img src="https://user-images.githubusercontent.com/44857109/104019041-2fc64c80-51fe-11eb-8c1a-2636fe0dbf09.png" width="60%" height="60%">

`Warehouse`는 이벤트를 브로드케스트할 때 그에 따라 다운 스트림 서비스들이 각자 원하는 방식대로 이벤트를 처리할 것이라고만 예상한다. 즉 업스트림 서비스는 다운 스트림 서비스가 요구하는 정보를 알 필요가 없다. 반대로 다운 스트림 서비스는 업스트림 서비스가 전달하는 이벤트에 대한 정보를 알고 있어야 한다. 이러한 책임의 분배는 느슨한 결합으로 이어진다.

- 이벤트
    - 정확히 무슨 일이 일어났는지에 대한 정보 또는 어떠한 사실
- 메시지
    - 메시지 브로커와 같은 비동기 통신 메커니즘을 통해 보내는 것
    - 즉 메시지는 매체, 이벤트는 매체의 페이로드임

### 구현