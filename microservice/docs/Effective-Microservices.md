# Effective Microservices: 10 Best Practices
## Microservice or Monolith
글쓴이는 모놀리식과 마이크로서비스 아키텍처는 상호보완적인 관계라고 말한다. 일반적으로 규모가 크고 복잡하거나 그렇게 될 가능성이 있는 어플리케이션은 마이크로서비스 아키텍처에 적합하다. 장기간 서비스해야 하는 어플리케이션은 모놀리식이 적합하다. 글쓴이는 이 두가지 아키텍처가 `SQL`과 `NoSQL`처럼 서로 공존하면서 사용될 것이라고 말한다.

## Best Practices

### 1. Domain Driven Design
마이크로서비스 개발의 가장 큰 과제는 크고 복잡한 어플리케이션을 작고 독립적으로 배포할 수 있는 모듈로 분할하는 것이다. 만약 설계를 잘못해서 올바른 방식으로 분할하지 않으면  모놀리식과 `분산된 모놀리식`으로 불리는 마이크로서비스의 단점을 모두 갖게 된다. 소프트웨어 엔지니어링 컨설턴트인 `Eric Evans`는 그의 책인 `Domain Driven Design: Tackling Complexity in the Heart of Software`에서 문제점을 해결하기 위한 3가지 핵심 개념을 설명한다.

- 개발팀은 비니지스 부서 또는 도메인 전문가와 긴밀히 협력해야 한다.
- 아키펙트/개발자 및 도메인 전문가는 먼저 경계가 있는 컨텍스트 및 관련 핵심 도메인, 유비쿼터스 언어, 하위 도메인, 컨텍스트 맵을 찾아야 한다.
- 그 다음 설계자/개발자는 핵심 도메인을 세분화된 블록(Entity, Aggregate ...)으로 분해하는 방식으로 디자인해야 한다.

대규모 시스템이 코어 도메인과 하위 도메인으로 나뉘고 코어 도메인과 하위 도메인이 하나 이상의 마이크로 서비스에 매핑되면 이상적인 마이크로서비스를 만들 수 있다.

### 2. Database per Microservice
복잡한 어플리케이션을 마이크로서비스로 분할한 뒤에 다음엔 데이터베이스를 어떻게 사용해야 할지에 관한 과제가 발생한다. 만약 서비스간에 데이터베이스를 공유한다면 스키마의 작은 변경이라도 팀 간의 동기화가 필요하게 된다. 또한 분산된 여러 서비스간의 트랜잭션/락을 관리하는 것도 매우 복잡해지기 때문에 마이크로서비스 간의 강력한 결합으로 이어진다. 따라서 모든 마이크로서비스에 자체 데이터베이스/테이블이 존재해야 한다.

### 3. Micro Frontends
모놀리식 프론트앤드 또한 모놀리식 백앤드만큼 비효율적이다. `iFrame` 또는 `React Component` 등을 통해서 Microfrontend를 개발해야 한다.

### 4. Continuous Delivery
만약 100개의 마이크로서비스로 구성된 시스템이 있고 하나의 마이크로서비스만 변경해야 하는 경우 다른 99개를 건드리지 않고 하나의 마이크로서비스만 업데이트할 수 있다. 하지만 자동화 도구(DevOps, CI/CD)없이 독립적으로 100개의 서비스를 배포하는 것은 매우 어렵다. 일반적으로 `CI/CD`는 마이크로서비스 아키텍처를 사용하기위한 전제 조건중 하나로 뽑힌다.   

### 5. Observability
많은 마이크로서비스가 컨테이너에서 실행되면서 전체 시스템의 관찰 가능성이 매우 중요하고 복잡해졌다. 많은 컨테이너/노드로 인해서 로그를 중앙 집계하기 복잡해졌다. 하지만 여러 솔루션이 개발되었다. `Elastic Stack`/`Splunk`과 `Prometheus` 등을 통해 업계수준의 로그 관리, 모니터링을 제공할 수 있다. 

보통 마이크로서비스에서 하나의 API요청은 다른 마이크로서비스에 대한 여러 개의 계단식 호출로 이어진다. 마이크로서비스 시스템의 지연시간을 분석하려면 각 서비스를 추적할 수 있는 도구가 필요하다. `Zipkin`/`Jaeger` 등이 이를 지원한다.  

### 6. Unified Tech Stack
각 마이크로서비스는 해당 서비스에 가장 적합한 프로그래밍 언어와 프레임워크를 사용해야 한다. CPU 처리량이 중요한 고성능 작업일 경우 C++/Rust를 사용할 수 있고, 머신러닝과 함께 작동한다면 Python을 사용할 수 있다. 하지만 확실한 이유없이 각각 다른 언어/프레임워크를 사용한다면 실제 이점없이 너무 많은 언어와 프레임워크를 사용하게 될 수 있다.

### 7. Asynchronous Communication
마이크로서비스 아키텍처에서 가장 어려운 설계 중 하나는 서비스가 서로 통신하고 데이터를 공유하는 방법이다. 가장 쉽고 일반적인 방법은 동기식인 `REST API`를 사용하는 것이다. 하지만 A->B, B->C, C->D 방식으로 호출이 이어지면 대기 시간이 길어진다. 또한 마이크로서비스는 분산 시스템이므로 종종 계단식 오류로 이어진다. 마이크로서비스 간의 동기식 통신은 긴밀한 결합으로 이어진다. 장기 솔루션의 경우 마이크로서비스는 비동기식 통신을 해야한다.

### 8. Microservice First
일부 전문가들은 신규 프로젝트인 경우 마이크로서비스 아키텍처는 많은 초기 비용을 필요로하기 때문에 느슨하게 결합된 모놀리식 아키텍처로 시작하는 것이 좋다고 주장한다. 글쓴이는 이에 반대한다. 실제로 모놀리식의 내부 모듈은 긴밀하게 결합되어 있으므로 마이크로서비스로 변환하기 어렵기 때문이다. 결과적으로 마이크로서비스 아키텍처를 사용할 계획이 있거나 예상된다면 처음부터 마이크로서비스로 시작하는 것이 좋다.

### 9. Infrastructure over Libraries
Netflix는 마이크로서비스 개발 초기에 `Java`를 주로 사용하여 개발했다. 또한 개발에 필요한 많은 자바 라이브러리(`Netflix OSS Stack`)을 개발했다. 나중에 Netfilx를 포함한 많은 회사가 Java가 부피가 크고 콜드 스타트 문제로 인해 마이크로서비스에 적합하지 않다고 판단했다. 이에 따라 Netflix는 마이크로서비스를 위한 자바 라이브러리 개발을 중단했고 이를 사용하고 있던 많은 회사들은 못참게 되었다. 글쓴이는 언어 별 라이브러리를 개발하는 것처럼 많은 투자를 하는 것보다 그냥 프레임워크(Service Meshes, API gateway)를 사용하는 것을 추천한다.

- 뭔가 마무리가 시원치 않다... 그냥 이미 있는거를 잘 긁어서 사용해라 라는 뜻인 것 같다.

### 10. Organizational Considerations
대충 기업, 구성원 구조에 따라 케바케가 된다는 이야기인 것 같다.

## 아티클에 있었던 더 읽어볼 거리
- [Microservice Architecture and its 10 Most Important Design Patterns](https://towardsdatascience.com/microservice-architecture-and-its-10-most-important-design-patterns-824952d7fa41)
- [Looking Beyond The Hype: Is Modular Monolithic Software Architecture Really Dead?](https://medium.com/@md.kamaruzzaman/looking-beyond-the-hype-is-modular-monolithic-software-architecture-really-dead-e386191610f8)
