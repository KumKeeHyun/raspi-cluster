# Microservice Architecture: A brief overview and why you should use it in your next project

## Background
`David Parnas`와 `Dijkstra`의 논문을 통해 `모듈형 소프트웨어 개발`이 등장했다. 크고 복잡했던 소프트웨어를 인터페이스를 통해 통신하는 여러개의 모듈로 분리한다. 이때 각 모듈은 느슨하게 결합되어야 하고 하나의 모듈은 잘 응집되도록 설계해야 한다. 1990년대에 인터넷과 웹이 널리 이용되면서 소프트웨어는 훨씬 더 복잡해지고 커졌다. 모듈성은 소프트웨어의 복잡성을 줄이는 데 목적을 두지만 모듈러의 경계가 애매하고 오용하기 쉬워서 도움이 되지 않았다. 이때 `계층화된 아키텍처`가 인기를 얻으면서 일반적인 비지니스 웹 어플리케이션은 표현단계, 비지니스 로직, 데이터페이스 등의 계층으로 나누어 개발되었다.
<br>

이때 대부분의 비지니스 어플리케이션에 다음과 같은 문제점이 있었다.

- 잘 정돈되지 않은 성장
- 너무 많은 책임
- 적절한 아키텍처의 부족
- 스파게티 코드
- 카펫 아래를 청소하는 문제
    - `sweeping problems under the carpet`이라 하는데 문제를 해결하려 하지않고 숨기려한다는 뜻? 인것 같다

2000년대 후반 스마트폰의 보급과 네트워크 속도가 빨라짐에 따라 소프트웨어 산업이 크게 발전했다. Facebook, Twitter, Netflix, Spotify같은 회사들의 혁신적인 아이디어, 공격적인 전략, 빠른 접근 방식에 따라 소프트웨어 어플리케이션의 복잡도가 폭발적으로 늘어났다. 소프트웨어의 크기가 커지면서 빠르게 어플리케이션을 개발하고 배포하는 데 모놀리식 아키텍처가 문제점으로 떠올랐다.

## Limitations of Monolithic Architecture
정리하긴 했지만 너무 나쁜점만 콕콕 찝어서 말해주는 것 같다. 

### Application Scaling
회사의 성장에 따라 소프트웨어의 규모는 **수평적**으로 성장해야 한다. 모놀리식 아키텍처는 하나의 프로그래밍 언어, 하나의 기술 스택을 이용해서 한 단위로만 개발된다. 이 제약이 수평적 확장을 어렵게 한다.

### Development Velocity
회사가 돈을 잘 벌려면 빨리빨리 개발하고 빨리빨리 배포해야 한다. 크고 복잡한 모놀리식 어플리케이션은 밀접하게 결합되어 있는 하나으 모듈이기 때문에 개발자에게 큰 부하를 준다. 모놀리식에 새로운 기능을 추가하는 것은 보통 어렵고 느리고 비용이 많이 드는 작업이다.

### Development Scaling
회사는 빨리빨리 서비스를 만들기 위해 많은 개발자를 고용하고 많은 개발자를 병렬화하여 효율적으로 개발하도록 해야 한다. 모놀리식에서는 여러 개발자가 자율적으로 개발할 수 없고 서로 동기화하는 추가 작업이 필요하다. 또 전체 코드 기발을 이해하는 것이 어렵기 때문에 신입이 빠르게 개발에 참여할 수 없다.


### Release Cycle
동일한 이유로 대규모의 모놀리식 어플리케이션은 릴리즈 주기가 크다.

### Modularization
모놀리식 아키텍처에서 모듈 간의 경계는 내부 인터페이스이다. 어플리케이션의 규모가 커지면 모듈 간의 경계가 무너지기 쉽기 때문에 `느슨하게 결합되고 응집력이 높아야 한다`를 지키기 어려워진다.

### Modernization
뭔소리인지 모르겠다.


## Microservice Architecture
2010년대에 `클라우드 컴퓨팅`, `컨테이너 기술`, `DevOps` 같은 기술이 등장했다. 또 `Golang`, `Rust`, `Swift`같은 매우 생산적이고 가벼운 새 프로그래밍 언어가 나오고 `JavaScript`, `Python`같은 생산적이고 쉬운 스크립트 언어도 프로그래밍 언어의 주류가 되었다. 

소프트웨어 개발 모델도 `폭포수 모델`이 폐기되었고 빠르고 반복적이며 점진적인 개발 방법론인 `에자일 방법론`으로 대체되었다. 하드웨어도 CPU의 코어 개수가 점점 늘어났고 데이터베이스에서는 `NoSQL`, `NewSQL`과 같은 기술이 등장하고 주류가 되었다.
<br>

이러한 변화를 활용하고 최신 소프트웨어 개발의 요구(빠른 개발, 수평 확장)를 충족하기 위해 2012년에 `마이크로서비스 아키텍처`가 등장했다. 글쓴이가 다음과 같이 정의했다.

> 마이크로서비스 아키텍처는 소프트웨어 시스템을 독립적으로 배포할 수 있고 언어에 구애받지 않는 경량 방식을 통해 통신하고 함께 비지니스 목표를 당성하는 자율 단위로 분해하는 것이다. 

![image](https://miro.medium.com/max/700/1*Koab_ZShvletO6JaPfyE6Q.jpeg)

## Pros
### Application Scaling
컨테이너 기술(Docker, Kubernetes)을 사용해서 몇 초 내에 수평 확장을 제공할 수 있다. 또 Python같은 스크립트 언어로 개발된 마이크로 서비스 사이에서 CPU 집약적인 서비스는 최적화를 위해 C/C++같은 언어로 별도로 구현할 수 있다.

### Development Speed
마이크로서비스는 크기가 작기 때문에 일반적으로 새로운 기능을 추가하는 것이 쉽고 빠르다.

### Development Scaling
마이크로서비스는 자율적이고 독립적으로 개발할 수 있다. 때문에 서로 다른 개발자/팀이 서로의 코드와 충돌하지 않고 병렬적으로 작업할 수 있으므로 개발자 확장성이 좋다.

### Release Cycle
모든 마이크로서비스는 독립적으로 배포할 수 있다. 결과적으로 릴리즈 주기가 작고 `CI/CD`를 사용하면 하루에 여러 릴리즈를 제공할 수도 있다.

### Modularization
마이크로서비스 간의 경계는 외부 인터페이스(물리적인 네트워크)이다. 때문에 모듈화를 잘 제공할 수 있다.

### Modernization
마이크로서비스가 서로 느슨하게 결합되어 있고 언어에 구애받지 않기 때문에 단일 서비스는 전체 시스템에 영향을 주지 않고 새로운 기술 스택을 채택해서 사용할 수 있다.

## Cons
### Design Complexity
마이크로서비스 아키텍처는 사용 사례에 따라 가능한 많은 솔루션이 있을 수 있다. 따라서 설계의 난이도가 높고 잘못된 설계를 하게될 확률도 높다. 일반적으로 잘못 설계된 마이크로서비스 보다는 모노리식이 더 좋다.

### Distributed Systems Complexity
마이크로서비스는 보통 분산 시스템이기 때문에 복잡하고 모놀리식에 비해 고유한 문제가 있다. 전제적으로 시스템 지연이 높고, 네트워크 장애 또는 개별 노드 장애에 대한 대비가 필요하며 운영 복잡성이 높다.

### Operational Complexity
로깅, 모니터링과 같은 작업이 하나의 시스템에서 더 많은 시스템을 처리해야 하기 때문에 운영 복잡성이 높아진다. 서비스 요청에 대한 개별 마이크로서비스의 성능/대기시간을 측정하기 위해 서비스에 대한 추적도 중요하다. 전체 시스템 테스트도 모놀리식보다 훨씬 복잡해진다. 일반적으로 마이크로서비스 아키텍처의 초기 개발속도는 운영 복잡성 때문에 모놀리식보다 낮다.

### Security
하나의 어플리케이션만 보호하는 것도 어려운데 수백개의 마이크로서비스를 보호하는 것은 더 못참는다.

### Data Sharing and Data Consistency
일반적으로 모든 마이크로서비스는 자체 데이터 저장도가 있어야 한다. 마이크로서비스는 비지니스 로직을 구현하기 위해 서로 데이터를 공유해야 하기때문에 데이터 일관성에 대해 잘 관리해야 한다. 고전적인 `two-phase commit`는 권장되지 않고 최신 데이터 저장소에서도 지원해주지 않는다.

### Communication Complexities
마이크로서비스는 물리적인 네트워크를 통해서만 통신할 수 있기 때문에 대기시간이 늘어난다. 서비스간 통신에는 `REST`, `gRPC`를 이용한 동기식 통신, `메시지 큐`, `메시지 브로커`을 이용한 비동기식 통신이 있다. 동기식 통신은 잘못 사용하면 분산된 모놀리식이 되기 쉽고 비동기식 통신은 더 큰 유연성을 제공하는 동시에 구현 복잡도, 비용이 늘어난다.

## 아티클에 있었던 더 읽어볼 거리
- 마이크로서비스의 문제점
    - [Goodbye Microservices: From 100s of problem children to 1 superstar](https://segment.com/blog/goodbye-microservices/)
    - [The Death of Microservice Madness in 2018](https://dwmkerr.com/the-death-of-microservice-madness-in-2018/)
- [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)