# File Format

디스크 기반 자료구조는 디스크의 제약과 특성을 고려하여 설계해야 함.

- 디스크 접근은 시스템콜을 통해 이뤄짐 -> 접근 비용이 매우 큼
- 디스크의 최소 작업 단위는 블록 -> 블록의 특정 부분을 읽으려면 블록의 전체를 읽어들여야 함
- 데이터 레코드를 바이너리 형식으로 직렬화, 역직렬화 작업이 필요 -> 추가적인 오버헤드
- (HDD)랜덤 I/O 비용이 매우 큼

즉, 디스크 자료구조는 디스크 접근 횟수를 최소화 해야 하고, 지역성을 높여서 페이지를 넘나드는 포인터를 최소화 해야 함.

## Slotted Page

페이지에 가변길이 레코드 저장시 발생하는 가장 큰 문제는 삭제된 레코드에 대한 공간 회수 및 관리임. 

- 공간 회수 시 효율적으로 페이지를 재작성하고 일부 레코드는 재배치해야 함
- 다른 페이지에서 재배치된 레코드를 참조할 수 있기 때문에 레코드의 오프셋을 유지해야 함
- 공간 단편화를 최소화 해야 함

슬릇 페이지는 위의 조건을 만족하며 문자열, BLOB 같은 가변길이 자료를 효율적으로 저장할 수 있음.

- 실제 레코드 위치를 가리키는 포인터 배열이 유일한 오버헤드임
- 셀의 위치가 바뀌더라도 포인터를 통해 접근하기 때문에 페이지 외부에서는 정확한 오프셋을 알 필요가 없음
- 셀 재배치 등 단편화 제거 및 공간 회수가 용이함

<img width="800" alt="출처:oreilly-database internals" src="https://user-images.githubusercontent.com/44857109/215307087-8aa2349a-a54f-4d4f-922c-ee2c48423fde.png">

## Checksum 

디스크에 저장된 파일은 SW/HW 장애 등으로 손상될 수 있음. 손상된 데이터가 다른 서브시스템에 전파되는 것을 방지하기 위해 checksum, CRC 등을 사용함.

- checksum : 보장성이 낮고 다중 비트 오류는 감지하지 못함
- CRC : 멀티 비트 오류를 감지할 수 있음

> CRC는 의도하지 않은 방법으로 데이터가 변경되었는지 확인하는 기법임. 보안을 위해 의도적인 데이터 변조를 감지하려면 암호화 해시를 사용해야 함.

일반적으로 페이지 단위로 체크섬을 계산하고 페이지 헤더에 저장함.

## 페이지 캐시

대부분의 데이터베이스는 디스크 접근 횟수를 줄이기 위해 디스크 자료구조에 특화된 페이지 캐시를 구현해 사용함.

<img width="800" alt="출처:oreilly-database internals" src="https://user-images.githubusercontent.com/44857109/215310650-c91fc4b0-7818-49d2-886c-48f182f2bf92.png">

> 많은 데이터베이스들은 `O_DIRECT` 플래그를 사용해 파일을 읽음. 이 플래그를 사용하면 I/O 시스템콜에서 커널 페이지 캐시를 우회하고 디스크에 직접 접근함. 이를 통해 데이터베이스에 특화된 버퍼 관리 기법을 사용할 수 있음.

캐시 크기가 클수록 더 많은 읽기 요청을 디스크에 접근하지 않고 처리할 수 있음. 동시에 한 페이지에 대한 변경 사항을 더 많이 버퍼링할 수 있음. 하지만 캐시 크기는 한정적이기 때문에 오래된 페이지는 제거해야 함. 이때 제거될 페이지가 더티 페이지라면 제거되기 이전에 디스크로 플러시해야 함.

페이지를 제거할 때마다 디스크로 플러시하는 것은 성능에 영향을 줄 수 있음. PostgreSQL에서는 `Background Flush Writer`를 통해 제거될 가능성이 높은 페이지를 백그라운드에서 주기적으로 플러시함.

B-Tree의 경우 상위 레벨 노드는 대부분의 읽기 작업에 사용됨. 요청될 확률이 높은 페이지는 캐시에 가둬두어 메모리에 더 오랜 시간 상주하게 함. 페이지 고정 or pinning 이라 함.