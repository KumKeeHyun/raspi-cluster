# Transaction

DBMS에서 트랜잭션이란 하나의 논리적 작업단위를 의미함. 여러 작업을 하나의 단계로 표현하는 방법임.

## Atomicity 원자성

트랜잭션과 관련된 작업들은 모두 실행되거나 모두 실패해야 함.

## Consistency 일관성

데이터베이스는 하나의 유효한 상태에서 또 다른 유효한 상태로 변경되야 함.

## Isolation 격리성

동시에 수행되는 각 트랜잭션은 다른 트랜잭션이 존재하지 않는 것 처럼 간섭 없이 수행되어야 함.

- 낙관적 동시성 제어 Optimistic Concurrency Control
  - 여러 트랜잭션이 동시에 읽고 쓰는 것을 허용
  - 결합된 여러 작업이 직렬화 가능한지 여부를 결정
  - 충돌이 발생할 경우 트랜잭션 중 하나를 중단함
- 비관적 동시성 제어 Pessimistic Concurrency Control
  - 잠금 방식 : 다른 트랜잭션이 같은 레코드를 동시에 수정 및 접근할 수 없도록 레코드에 잠금을 검
  - 무잠금 방식 : 
- 다중 버전 동시성 제어 Multiversion Concurrency Control
  - 여러 버전의 레코드를 저장해 특정 타임스탬프에서 일관성을 보장
  - timestamp ordering, lockless, 2-phase locking 같은 방식으로 구현

### 격리 수준

동시에 수행되는 트랜잭션이 고립된 정도화 수행 중에 이상 현상이 발생할 수 있는지를 나타냄. 트랜잭션을 격리하려면 불완전하거나 일시적인 데이터가 트랜잭션 경계를 넘어 전파되는 것을 막아야 함. 이를 위해 추가적인 코디네이션과 동기화가 필요하기 때문에 성능와 trade-off 관계임.

SQL 표준은 읽기 이상 현상을 3가지로 분류함.

- dirty read
  - 아직 커밋되지 않은 다른 트랜잭션의 중간 결과를 읽는 현상
- non-repeatable read
  - 트랜잭션이 동일한 레코드를 두 번 쿼리했을 때 둘의 결과가 다른 현상
  - 두 쿼리 사이에 다른 트랜잭션이 레코드를 수정하고 커밋한 경우 두번째 쿼리에서 수정한 레코드가 반환됨
- phantom read
  - 트랜잭션이 여러 레코드(범위)를 두 번 쿼리했을 때 둘의 결과가 다른 현상
  - 다른 트랜잭션이 insert, delete 한 레코드에 대해 나타남

격리 수준은 각 수준에서 허용되는 이상 현상을 나타냄

레벨|Dirty Read|Non-Repeatable Read|Phantom Read|
|:-:|:--------:|:------------------:|:---------:|
|Read Uncommitted|O|O|O|
|Read Committed|X|O|O|
|Repeatable Read|X|X|O|
|Serializable|X|X|X|

일부 데이터베이스는 Snapshot 격리 수준을 지원함. 트랜잭션의 시작 시점에 다른 트랜잭션이 커밋한 내용을 읽음. 트랜잭션에서 수정한 레코드가 수행 중에 변경되지 않은 경우에만 커밋되고 변경됐다면 중단 후 롤백됨. 즉 두 개의 트래잭션이 같은 값을 수정할 경우 한 트랜잭션만 커밋됨.

## Durability 지속성

트랜잭션 커밋 후 디스크에 저장된 상태는 시스템이 중단되거나 장애가 발생해도 그래도 유지되어야 함.

### 복구

SW/HW 전반에서 장애가 발생할 수 있기 때문에 데이터베이스는 여러 장애 시나리오를 고려해야 함.

`WAL`은 장애 및 트랜잭션 복구를 위해 디스크에 저장하는 append-only 보조 자료구조임. 페이지 캐시는 페이지에 대한 변경 사항을 메모리에 버퍼하기 때문에 더티 페이지가 플러시될 때까지 손실될 수 있는 변경 작업 로그들을 디스크에 유지함.

스틸/노스틸, 포스/노포스 정책을 기반으로 메모리에 캐시된 변경 사항을 디스크로 플러시하는 시점을 결정함.

- 스틸 : 트랜잭션이 수정한 페이지를 커밋하기 전에 플러시하는 것을 허용
  - 노스틸 : 커밋되지 않은 트랜잭션이 디스크로 플러시되는 것을 허용하지 않음
- 포스 : 트랜잭션이 수정한 모든 페이지를 커밋 전에 플러시함
  - 노포스 : 일부 페이지가 플러시되지 않았더라도 커밋을 허용

노스틸 정책 사용 시 이전 상태의 페이지가 디스크에 저장되어있기 때문에 리두 로그만 사용하여 상태를 복구할 수 있음. 노포스 정책 사용 시 플러시 시점을 늦출 수 있기 때문에 더 많은 변경 사항을 버퍼링할 수 있음.

`ARIES`는 스틸/노포스 정책 기반의 복구 알고리즘임. 빠른 복구를 위해 물리적 리두 로그와 동시성을 높이기 위해 논리적 언두 로그를 사용함. 1992년에 처음 발표됐지만 기본 개념, 접근 방식은 요즘에도 사용됨.