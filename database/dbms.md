# DBMS

## 데이터베이스 비교

- 데이터베이스는 대부분 마이그레이션 비용이 크기 때문에 때문에 신중하게 선택해야 함.
- 먼저 목표를 명확하게 정해야 함. 사용 목적을 구체적으로 파악해야 함.
  - 스키마와 레코드 크기
  - 클라이언트 수
  - 쿼리 형식과 접근 패턴
  - 읽기와 쓰기 쿼리 비율
- 위 변수를 미리 정의할 수 있다면 다음 질문에 대해 답해야 함.
  - 요청된 쿼리를 수행할 수 있는가?
  - 데이터를 모두 저장할 수 있는가?
  - 단일 노드는 몇 개의 읽기/쓰기 쿼리를 처리할 수 있는가?
  - 몇 개의 노드가 필요한가?
  - 변화하는 요구사항에 맞추어 클러스터를 확장할 수 있는가?
  - 유지보수는 어떻게 할 것인가?
- 위 질문에 댑할 수 있다면 테스트 클러스터를 구성하고 워크로드를 시뮬레이션함.
  - 대부분의 데이터베이스는 특정 사용 패턴을 재현할 수 있는 부하 테스트 툴을 제공함.
  - 만약 표준 툴이 없거나 사용할 수 없다면 다른 범용 툴을 사용하거나 직접 구현해야 함.
- (오픈소스 한정) 데이터베이스의 구조를 파악하고 각 컴포넌트에 해당하는 코드를 찾을 수 있어야 함.
  - 데이터베이스가 생성하는 로그나 다양한 설정 값의 의미를 더 잘 이해할 수 있음.
  - 트러블 슈팅에 도움이 될 수 있음.
- 최신 버전에 정확이 무엇이 변경됐고 왜 변경됐는지 파악하고 업그레이드 전략을 세워 두는 것이 좋음.
  - 새로운 버그, 성능 저하 또는 예기치 않은 문제가 발생할 수 있음.
  - 지금까지 어떤 방향으로 개선되었는지 파악하면 앞으로의 업그레이드 방향을 미리 예측할 수 있음.

## 일반적인 DBMS 구조 

<img height="800" alt="image" src="https://user-images.githubusercontent.com/44857109/214763977-b9174d6c-a646-470d-83a1-8c5dd9ecc763.png">

- Transport
  - 클라이언트 요청 수신 및 응답
  - 클러스터 내 노드간 통신
- Query Processor
  - 쿼리 파싱, 유효성 검사
  - 데이터 통계(인덱스 카디널리티 등)과 위치(클러스터 내 저장 위치 및 전송 비용 등) 등을 기반으로 가장 효율적인 쿼리 실행 계획 생성
  - 실행 계획(execution plan, query plan)은 쿼리의 결과를 도출하는 데 수행해야 하는 일련의 작업
  - 같은 쿼리라도 여러 실행 게획이 존재할 수 있음. 옵티마이저는 가장 효율적인 실행 계획 선택 
- Execution Engine
  - 로컬 및 원격 실행의 결과를 취합
  - 원격 실행은 클러스터 내 노드간 읽기, 쓰기, 복제 등을 포함
- Storage Engine
  - 로컬 쿼리 수행
  - Transaction Manager
    - 트랜잭션을 스케줄링
  - Lock Manager
    - 트랜잭션간 동시에 접근하는 객체에 대한 잠금을 제어
  - Access Method
    - 디스크에 저장할 자료구조 및 접근 방식을 정의
    - B-Tree, LSM Tree 등 
  - Buffer Manager
    - 디스크 I/O를 최소화 하기 위한 페이지 캐싱 및 관리
    - 대부분은 최적화를 위해 OS의 페이징의 지원을 우회하고 직접 페이지 교체 정책을 구현
  - Recovery Manager
    - 매 요청마다 디스크에 접근하지 않기 때문에 캐싱된 데이터가 휘발되지 않도록 추가적인 로그를 구성

## 인메모리 vs 디스크 기반

### 인메모리

- 메모리에 데이터를 저장, 디스크는 복구와 로그 저장 용도로 사용
- OS의 메모리 추상화의 지원을 기반으로 임의의 청크를 할당하고 해제하는 작업 정도로 제어 가능
- 반면에 RAM의 상대적으로 높은 가격과 휘발성이 단점
  - 무정전 전원 장치와 배터리 장착 RAM을 사용할 수 있지만 추가적인 관리이므로 비용이 추가됨
  - 비휘발성 램(NVM) 기술이 대중화되면 주류가 될 수도??

### 디스크 기반

- 디스크에 데이터를 저장, 메모리는 캐시 또는 임시 저장 용도로 사용
- 페이지 케싱, 데이터 직렬화, 디스크 포멧, 단편화 등의 이슈를 모두 직접 관리해야 함
- 반면에 메모리보다 유지관리 측면에서 더 간단하고 비용이 적은 것이 장점

## Row 기반 vs Column 기반

<img width="800" alt="image" src="https://user-images.githubusercontent.com/44857109/214770470-c6d46d72-0be0-4732-98a2-5d85c11e14f9.png">

### Row 기반

- 위 그림의 b 저장 방식
- MySQL, PostgreSQL 등 대부분의 관계형 데이터베이스가 사용
- 공간 지역성을 극대화
- 특정 행의 모든 컬럼을 읽을 때 적함
- 다수 행의 특정 컬럼을 읽을 때 부적합
  - 필요 없는 컬럼까지 같이 페이징 되기 때문
  
### Column 기반

- 위 그림의 a 저장 방식
- Parquet, Kudu 등이 사용
- 일부 컬럼만 읽거나 복잡한 집계, 통계 작업에 적합

### Wide Column

