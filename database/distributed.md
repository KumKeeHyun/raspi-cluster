# Distributed System

## 분산 컴퓨팅의 오류

### 1. 프로세싱

원격 프로세스는 전달받은 메시지에 대한 응답을 보내기 위해 로컬 프로세스를 수행해야 함. 따라서 원격 프로세싱을 즉각적이라고 가정할 수 없음. 나아가 메시지가 전달되는 즉시 작업을 처리한다는 보장도 없음. 원격 서버의 대기열에 먼저 등록된 메시지가 모두 처리될 때까지 기다려야 할 수 있음.

노드는 물리적으로 위치가 멀 수 있고 HW 성능 및 SW 버전, 환경설정 등이 다를 수 있음. 따라서 모든 노드의 요청을 처리하는 속도가 같을 것이라 가정할 수 없음. 

### 2. 상태 일관성

분산 알고리즘은 상태에 대한 일관성을 완벽하게 보장하지 않음. 일부는 제약 조건이 엄격하지 않고 복제 노드 간의 상태 차이를 허용하고 `conflict resolution`, `read-time data repair`등을 통해 상태 차이를 해결함.

Eventually consistency을 보장하는 시스템은 읽기 중에 노드 쿼럼을 쿼리해 복제 노드 사이의 상태 불일치를 해결하는 로직이 있을 수 있음(과반수의 상태가 일치하는 것으로 결정). 이 경우 실제 데이터베이스의 스키마와 클러스터의 뷰가 완전히 일치한다고 가정함. 하지만 둘의 일관성을 생각하지 않고 가정에 의존하면 문제가 생길 수 있음.

Apache Cassandra는 스키마 변경사항이 각 노드에 완전히 전파되지 않은 상황에서 쿼리를 수행했을 때 데이터가 손상되는 버그가 발견됐었음. 

### 3. 장애 처리

모든 노드가 항상 정상적으로 작동한다고 가정하는 것은 위험함. 노드가 점검을 위해 중단되기도 하고 런타임 버그, 하드웨어 문제 등으로 노드에 장애가 발생하기도 함. 따라서 각 장애 상활에 대비하고 어떻게 대처할 수 있을지 고민해야 함.

원격 서버가 응답하지 않는 정확한 이유를 항상 알 수 없음. 충돌, 네트워크 장애, 원격 프로세스 속도 저하 등 다양한 원인이 있을 수 있음. 일부 분산 알고리즘은 `heartbeat protocol`, `failure detector`를 통해 어떤 노드가 살아있고 접근 가능한지 알아냄.

### 4. 네트워크 파티션과 부분 장애

2개 이상의 서버가 서로 통신할 수 없는 상황을 네트워크 파티션이 발생했다고 함. 네트워크 파티션은 격리된 각 그룹들이 각자 작업을 수행해 결과가 충돌 할 수 있음.

한 개 이상의 프로세스에 장애가 발생해도 정상 작동하는 견고한 시스템을 구축하려면 부분적인 장애 상활에 대응해야 함. 시스템 일부에 접근할 수 없거나 기능에 문제가 생겨도 시스템은 계속해서 작동해야 함.

### 5. 계단식 장애

특정 프로세스의 사용량이 급증하면 결국 클러스터 전체의 사용량이 증가해 다른 노드에도 장애가 발생할 수 있음. 계단식 장애는 한 부분에서 다른 부분으로 전파돼 오류의 범위를 확장함. 

잠시동안 오프라인 상태가 된 노드가 최신 업데이트 내용을 전달받기 위해 데이터를 스트리밍 받을 경우, 네트워크 리소스를 과다하게 사용하는 등의 문제로 다른 노드에도 영향을 미칠 수 있음. 

특정 서버와의 연결이 끊어지거나 응답이 오지 않는 경우 클라이언트는 지속적으로 연결을 재시도함. 이때 과부하에 걸린 서버는 새로운 요청을 처리하는데 바쁘기 때문에 연결 재요청은 상황을 악화시킬 수 있음. 이를 방지하기 위해 연결을 바로 재시도하지 않고 잠시 대기하는 backoff 전략을 사용하기도 함.

부하와 핫스팟은 작업을 미리 계획하고 조정해서 문제를 방지할 수 있음. 각 노드가 독립적으로 작업을 수행하지 않고 코디네이터가 가용 리소스를 기반으로 실행 계획을 준비하고 과거 실행된 자료를 기반으로 부하를 예측해야 함.

## 링크

네트워크는 신뢰성이 낮음. 메시지는 분실되거나 지연될 수 있고 순서가 바뀔 수도 있음. 신뢰성을 높이고 개선하기 위한 노력이 필요함.

### 1. 손실될 수 있는 링크

링크로 연결된 두 개의 프로세스. 송신자의 관점에서 메시지의 상태는 다음 중 하나임.

- 원격 프로세스에 성공적을 전달됨
- 아직 원격 프로세스에 전달되지 않음(결과적으로는 전달됨)
- 메시지가 전송 중에 손실됨

<img width="620" alt="출처:oreilly-database internals" src="https://user-images.githubusercontent.com/44857109/215693585-542f41fb-9534-48fd-aa53-9bd355d74e18.png">

송신자가 메시지의 전달 여부를 확인할 수 없는 위와 같은 링크를 `fair-loss links(손실 허용 링크)`라 함. 메시지는 시스템적으로 손실될 수 없고 새로운 메시지가 생성되지 않지만 완전히 신뢰할 수는 없음. UDP와 비슷함. 특성은 다음과 같음.

- 손실 허용성 Fair loss 
  - 송신자가 무한히 재전송한 메시지는 결과적으로 전달됨
- 유한 중복성 Finite duplication
  - 메시지는 무한하게 중복 전달되지 않음
- 생성 불가성 No creation
  - 전송하지 않은 메시지는 절대 전달될 수 없음

### 2. 메시지 확인 응답(ACK)

메시지의 상태를 정확히 판단하기 위해 수신자가 메시지를 수신했음을 알리는 `acknowledgement`를 사용할 수 있음. 이를 위해 양방향 채널과 시퀀스 번호화 같은 메시지 식별자가 필요함. 

<img width="620" alt="출처:oreilly-database internals" src="https://user-images.githubusercontent.com/44857109/215696129-b2566d6f-cbd3-48b8-bb82-13c7f7e59c5b.png">

A가 ack를 받기 전까지는 fair-loss의 3가지 상태 중 하나일 수 있음. ack를 받는 즉시 B에 성공적으로 전달됐다고 확신할 수 있음.

### 3. 메시지 재전송

ack 응답만으로는 완전히 신뢰할 수 없음. 메시지가 누락될 수 있는 것은 여전하고 ack를 보내기 전에 원격 프로세스에 장애가 발생할 수도 있음. 메시지를 재전송해서 이런 문제를 해결할 수 있음. 즉 잠재적으로 실패한 전송 작업을 재시도 하는 것임.

프로세스 사이의 링크가 온전하고 네트워크 파티션이 무한히 지속되지 않으며 패킷이 모두 손실되지 않는다고 가정한다면 A 관점에서 메시지는 B에 전달되거나 아직 전달되지 않은 상태임. 이러한 링크를 `stubborn links(스터번 링크)`라 함.

#### 멱등성 Idempotent

단순히 메시지를 재전송하면 불필요한 중복이 발생할 수 있음. 메시지가 멱등 연산인 경우에는 중복되었더라도 안전하게 처리할 수 있음. 만약 모든 연산이 멱등적이라면 복잡해지지 않음. 하지만 모든 연산이 멱등적일 수는 없음. 따라서 작업의 의미를 바꾸지 않고 멱등성에 준하는 결과를 보장하는 방법이 필요함. 중복 제거 기능을 사용하면 중복 처리하는 것을 방지할 수 있음. 

### 4. 중복 제거

누락, 재전송 같은 상황으로 인해 순서대로 도착하지 않는 메시지들을 각 메시지에 부여된 식별자를 이용하여 정렬하고 중복된 메시지를 제거할 수 있음. 이러한 링크를 `perfect links(퍼펙트 링크)`라 함.

- 전송 신뢰성 Reliable delivery
  - 정상적인 두 프로세스 사이에서 전달된 메시지는 결과적으로 무조건 전달됨
- 비중복성 No duplication
  - 모든 메시지는 한 번만 전달됨
- 생성 불가성 No creation
  - 실제로 전송된 메시지만 전달됨


#### 정확히 한 번 전달 Exactly-once delivery

모든 메시지를 한 번만 전송하는 신뢰할 수 있는 링크는 존재할 수 없음. 대신 모든 메시지를 한 번만 처리하고 중복된 메시지는 무시하는 것은 가능함. 송신자 관점에서 정확히 한 번만 전달된 것과 같이 보이게 하는 것은 가능함.

## 동기성

## 장애 모델

분산 시스템의 프로세스에 발생할 수 있는 장애를 정의한 모델. 

### 충돌 Crash



### 누락 Omission


### 임의의 장애